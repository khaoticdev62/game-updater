import { HybridEventBus } from '../src/eventBus';
import { spawn } from 'child_process';
import { EventEmitter } from 'events';

jest.mock('child_process');

describe('HybridEventBus', () => {
  let bus: HybridEventBus;
  let mockSidecar: unknown;

  beforeEach(() => {
    const emitter = new EventEmitter();
    const mockWithInputs = emitter as unknown as {
      stdin: { write: jest.Mock };
      stdout: EventEmitter;
      stderr: EventEmitter;
      kill: jest.Mock;
    };
    mockWithInputs.stdin = { write: jest.fn() };
    mockWithInputs.stdout = new EventEmitter();
    mockWithInputs.stderr = new EventEmitter();
    mockWithInputs.kill = jest.fn();
    mockSidecar = mockWithInputs;

    (spawn as jest.Mock).mockReturnValue(mockSidecar);
    bus = new HybridEventBus();
  });

  afterEach(() => {
    bus.stop();
  });

  test('request should timeout if no response is received', async () => {
    bus.start();
    
    // We expect the request to fail with a timeout error
    await expect(bus.request({ command: 'test' }, 100))
      .rejects.toThrow('Request timed out after 100ms');
  });

  test('request should resolve if response is received in time', async () => {
    bus.start();

    const requestPromise = bus.request({ command: 'test' }, 1000);

    // Simulate response from sidecar
    // We need to capture the ID generated by the bus.
    // Since we mocked stdin.write, we can get it from there.
    const sidecarMock = mockSidecar as { stdin: { write: jest.Mock }, stdout: EventEmitter };
    const lastCall = sidecarMock.stdin.write.mock.calls[0][0];
    const requestData = JSON.parse(lastCall.trim());
    const reqId = requestData.id;

    const response = { id: reqId, result: 'success' };
    sidecarMock.stdout.emit('data', Buffer.from(JSON.stringify(response) + '\n'));

    const result = await requestPromise;
    expect(result).toEqual(response);
  });
});
