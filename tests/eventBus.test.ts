import { HybridEventBus } from '../src/eventBus';
import { spawn } from 'child_process';
import { EventEmitter } from 'events';

jest.mock('child_process');

describe('HybridEventBus', () => {
  let bus: HybridEventBus;
  let mockSidecar: any;

  beforeEach(() => {
    mockSidecar = new EventEmitter();
    mockSidecar.stdin = { write: jest.fn() };
    mockSidecar.stdout = new EventEmitter();
    mockSidecar.stderr = new EventEmitter();
    mockSidecar.kill = jest.fn();

    (spawn as jest.Mock).mockReturnValue(mockSidecar);
    bus = new HybridEventBus();
  });

  afterEach(() => {
    bus.stop();
  });

  test('request should timeout if no response is received', async () => {
    bus.start();
    
    // We expect the request to fail with a timeout error
    await expect(bus.request({ command: 'test' }, 100))
      .rejects.toThrow('Request timed out after 100ms');
  });

  test('request should resolve if response is received in time', async () => {
    bus.start();

    const requestPromise = bus.request({ command: 'test' }, 1000);

    // Simulate response from sidecar
    // We need to capture the ID generated by the bus.
    // Since we mocked stdin.write, we can get it from there.
    const lastCall = (mockSidecar.stdin.write as jest.Mock).mock.calls[0][0];
    const requestData = JSON.parse(lastCall.trim());
    const reqId = requestData.id;

    const response = { id: reqId, result: 'success' };
    mockSidecar.stdout.emit('data', Buffer.from(JSON.stringify(response) + '\n'));

    const result = await requestPromise;
    expect(result).toEqual(response);
  });
});
